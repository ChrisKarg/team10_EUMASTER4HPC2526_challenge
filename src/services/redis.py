"""
Redis Service and Client implementations
"""

import logging
from typing import Dict, Any, List, Optional
from .base import Service, Client, JobFactory


class RedisService(Service):
    """Redis in-memory database service implementation"""
    
    @classmethod
    def from_recipe(cls, recipe: Dict[str, Any], config: Dict[str, Any]) -> 'RedisService':
        """Create RedisService from recipe dictionary"""
        service_def = recipe.get('service', {})
        
        return cls(
            name=service_def.get('name', 'redis'),
            container_image=service_def.get('container_image', 'redis_latest.sif'),
            resources=service_def.get('resources', {}),
            environment=service_def.get('environment', {}),
            config=config,
            ports=service_def.get('ports', [6379]),
            command=service_def.get('command', 'redis-server'),
            args=service_def.get('args', []),
            container=service_def.get('container', {})
        )
    
    def get_service_setup_commands(self) -> List[str]:
        """Setup Redis configuration files based on persistence settings"""
        commands = [
            "# Redis setup",
            "mkdir -p $HOME/redis/data",
            "mkdir -p $HOME/redis/config",
            "",
            "# Create Redis configuration file",
            "cat > $HOME/redis/config/redis.conf << 'EOF'",
            "# Redis configuration generated by HPC Orchestrator",
            "",
            "# Network",
            "bind 0.0.0.0",
            "port 6379",
            "protected-mode no",
            "",
            "# General",
            "daemonize no",
            "pidfile /var/run/redis.pid",
            "loglevel notice",
            "logfile \"\"",
            "",
            "# Directory for data",
            "dir /redis/data",
            "",
            "# Memory Management",
            "maxmemory-policy allkeys-lru",
        ]
        
        # Get persistence configuration from environment or use defaults
        persistence_mode = self.environment.get('REDIS_PERSISTENCE', 'both')
        
        if persistence_mode in ['aof', 'both']:
            commands.extend([
                "",
                "# AOF Persistence",
                "appendonly yes",
                "appendfilename \"appendonly.aof\"",
                "appendfsync everysec",
                "no-appendfsync-on-rewrite no",
                "auto-aof-rewrite-percentage 100",
                "auto-aof-rewrite-min-size 64mb",
            ])
        else:
            commands.extend([
                "",
                "# AOF Persistence - Disabled",
                "appendonly no",
            ])
        
        if persistence_mode in ['rdb', 'both']:
            commands.extend([
                "",
                "# RDB Persistence",
                "save 900 1",
                "save 300 10",
                "save 60 10000",
                "stop-writes-on-bgsave-error yes",
                "rdbcompression yes",
                "rdbchecksum yes",
                "dbfilename dump.rdb",
            ])
        else:
            commands.extend([
                "",
                "# RDB Persistence - Disabled",
                "save \"\"",
            ])
        
        # Add security settings if password is provided
        password = self.environment.get('REDIS_PASSWORD', '')
        if password:
            commands.extend([
                "",
                "# Security",
                f"requirepass {password}",
            ])
        
        commands.extend([
            "EOF",
            "",
            "echo 'Redis configuration created:'",
            "cat $HOME/redis/config/redis.conf",
            ""
        ])
        
        return commands
    
    def get_container_command(self) -> str:
        """Generate Redis container execution command"""
        cmd_parts = ["apptainer exec"]
        
        # Add bind mounts for Redis data and config
        cmd_parts.append("--bind $HOME/redis/data:/redis/data")
        cmd_parts.append("--bind $HOME/redis/config:/redis/config")
        
        # Add environment variables
        for key, value in self.environment.items():
            cmd_parts.append(f"--env {key}={value}")
        
        # Resolve container path
        container_path = self._resolve_container_path()
        cmd_parts.append(container_path)
        
        # Redis command with config file
        cmd_parts.append("redis-server")
        cmd_parts.append("/redis/config/redis.conf")
        
        # Run in background
        cmd_parts.append("&")
        
        return " ".join(cmd_parts)
    
    def get_health_check_commands(self) -> List[str]:
        """Redis-specific health monitoring"""
        password = self.environment.get('REDIS_PASSWORD', '')
        auth_flag = f"-a {password}" if password else ""
        
        return [
            "",
            "# Wait for Redis to start",
            "sleep 5",
            "",
            "# Get the Redis process ID",
            "REDIS_PID=$!",
            "",
            "# Display Redis endpoint",
            "echo '========================================='",
            "echo 'Redis is running on:'",
            "echo \"redis://$(hostname):6379\"",
            "echo '========================================='",
            "",
            "# Check if Redis is responding",
            "for i in {1..10}; do",
            f"    if redis-cli {auth_flag} -h localhost -p 6379 ping > /dev/null 2>&1; then",
            "        echo \"Redis is ready!\"",
            f"        redis-cli {auth_flag} -h localhost -p 6379 INFO server | grep redis_version",
            "        break",
            "    fi",
            "    echo \"Waiting for Redis to be ready... ($i/10)\"",
            "    sleep 3",
            "done",
            "",
            "# Monitor Redis process",
            "echo 'Monitoring Redis... (press Ctrl+C to stop)'",
            "while kill -0 $REDIS_PID 2>/dev/null; do",
            "    sleep 60",
            "    echo \"Redis still running on $(hostname):6379\"",
            f"    redis-cli {auth_flag} -h localhost -p 6379 INFO stats | grep total_connections_received || true",
            "done",
            "",
            "echo 'Redis service finished'"
        ]


class RedisClient(Client):
    """Redis benchmark client implementation"""
    
    @classmethod
    def from_recipe(cls, recipe: Dict[str, Any], config: Dict[str, Any]) -> 'RedisClient':
        """Create RedisClient from recipe dictionary"""
        client_def = recipe.get('client', {})
        
        # Parse script configuration
        script_config = client_def.get('script', {})
        script_name = script_config.get('name')
        script_local_path = script_config.get('local_path')
        script_remote_path = script_config.get('remote_path')
        
        return cls(
            name=client_def.get('name', 'redis_benchmark'),
            container_image=client_def.get('container_image', 'benchmark_client.sif'),
            resources=client_def.get('resources', {}),
            environment=client_def.get('environment', {}),
            config=config,
            command=client_def.get('command'),
            args=client_def.get('args', []),
            target_service=client_def.get('target_service', {}),
            duration=client_def.get('duration', 300),
            parameters=client_def.get('parameters', {}),
            script_name=script_name,
            script_local_path=script_local_path,
            script_remote_path=script_remote_path,
            container=client_def.get('container', {})
        )
    
    def resolve_service_endpoint(self, target_service_host: str = None, 
                               default_port: int = 6379, protocol: str = "redis") -> str:
        """Resolve Redis service endpoint"""
        # Check if endpoint is explicitly set in parameters
        endpoint_from_params = self.parameters.get('endpoint')
        if endpoint_from_params:
            return endpoint_from_params
        
        # Use TARGET_SERVICE_HOST environment variable
        host = target_service_host or "${TARGET_SERVICE_HOST}"
        
        # Get port from target service config or use Redis default (6379)
        if self.target_service and isinstance(self.target_service, dict):
            port = self.target_service.get('port', 6379)
        else:
            port = 6379
        
        # Return Redis-specific endpoint format (host:port for redis-py)
        return f"{host}:{port}"
    
    def get_container_command(self) -> str:
        """Override to handle boolean flags properly for Redis benchmark"""
        cmd_parts = ["apptainer exec"]
        
        # Add environment variables
        for key, value in self.environment.items():
            cmd_parts.append(f"--env {key}={value}")
        
        # Mount benchmark scripts directory
        scripts_dir = self.config.get('benchmark', {}).get('scripts_dir', '$HOME/benchmark_scripts')
        cmd_parts.append(f"--bind {scripts_dir}:/app")
        
        # Resolve container path
        container_path = self._resolve_container_path()
        cmd_parts.append(container_path)
        
        # Build Python command
        script_name = self.script_name or "redis_benchmark.py"
        python_cmd = f"python /app/{script_name}"
        
        # Add endpoint parameter
        endpoint = self.resolve_service_endpoint()
        if endpoint:
            python_cmd += f" --endpoint={endpoint}"
        
        # Add other parameters, handling booleans specially
        for key, value in self.parameters.items():
            if key == 'endpoint':  # Skip endpoint as it's handled above
                continue
            
            cli_key = key.replace('_', '-')
            
            # Handle boolean flags (no value, just the flag)
            if isinstance(value, bool):
                if value:  # Only add flag if True
                    python_cmd += f" --{cli_key}"
            else:
                python_cmd += f" --{cli_key}={value}"
        
        # Run inside container
        cmd_parts.extend(["bash", "-c", f'"pip install -q requests && {python_cmd}"'])
        
        return " ".join(cmd_parts)


# Register the Redis implementations with the factory
JobFactory.register_service('redis', RedisService)
JobFactory.register_client('redis', RedisClient)

